# 数据库事务与隔离级别

## 事务ACID特性

### 原子性（Atomicity）

原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。

### 一致性（Consistency）

一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。

如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变。

### 隔离性（Isolation）

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。

关于隔离性中的事务隔离等级，下面会说明。

### 持久性（Durability）

持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

## 读现象

事务不隔离会带来的问题：

* 更新丢失(Lost updates): 针对并发写数据

    两事务同时更新，A失败回滚覆盖B事务的更新，或事务A执行更新操作，在事务A结束前事务B也更新，则事务A的更新结果被事务B的覆盖。

* 脏读(Dirty reads): 针对未提交数据

    事务A对数据进行了更新，但还没有提交，事务B可以读取到事务A没有提交的更新结果，这样造成的问题就是，如果事务A回滚，那么，事务B在此之前所读取的数据就是一笔脏数据。

* 不可重复读(Non-repeatable reads): 针对其他提交前后，读取数据本身的对比

    不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务A在事务B的更新操作之前读取一次数据，在事务B的更新操作之后再读取同一笔数据一次，两次结果是不同的。

* 幻读(Phantom reads): 针对其他提交前后，读取数据条数的对比

    幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。

### 不可重复读与幻读的区别

不可重复读的重点是修改，指的是同样条件读取过的数据，再次读取出来发现值不一样。
幻读的重点是数据条数的变化（新增或删除），指的是同样的条件，两次读出来的记录数不一样

## 事务隔离级别

数据库事务有四种隔离级别，由低到高分别为：

* 读未提交（Read uncommitted，RU）

   最低的隔离级别，指的是一个事务可以读其他事务未提交的数据。

* 读提交（Read committed，RC）

    一个事务要等另一个事务提交后才能读取数据。

* 可重复读（Repeatable Read，RR）

    在开始读取数据（事务开启）时，不再允许修改操作。

* 串行化（Serializable，S）

    最高的事务隔离级别，事务串行化顺序执行。

### 隔离级别与读现象

|              | 更新丢失 | 脏读 | 不可重复读 | 幻读 |
|--------------|----------|------|------------|------|
| 读未提交(RU) | 避免     |      |            |      |
| 读提交(RC)   | 避免     | 避免 |            |      |
| 可重复读(RR) | 避免     | 避免 | 避免       |      |
| 串行化(S)    | 避免     | 避免 | 避免       | 避免 |

#### 参考文档

* [Isolation (database systems)](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Read_phenomena)