# 数据库事务与隔离级别

## 数据库事物处理（Transaction）

读数据错误与丢失更新

- [事务隔离级中](https://juejin.im/post/5b90cbf4e51d450e84776d27)，脏读、不可重复读、幻读三个问题都是由事务 A 对数据进行修改、增加，事务 B 总是在做读操作造成的。

如果两事务都在对数据进行修改则会导致另外的问题：丢失更新。为什么出现丢失更新：

- 多个 session 对数据库同一张表的同一行数据进行修改，时间线上有所重复，可能会出现各种写覆盖的情况。
- 示例可见：[并发事务的丢失更新及其处理方式](https://blog.csdn.net/u014590757/article/details/79612858)

解决方案：

- 根据具体的业务场景，尽量缩小事物范围并采用正确的[事物隔离级别](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)。
- 使 用数据库行级锁（如乐观锁、S 锁）。完全避免对行级数据的脏操作，但是使得对该行数据的访问串行化，对于比较大的表对象而言，这样的设置往往不是我们想要的结果。
- 缩小事务管辖的范围。控制事务所辖代码执行时间的长度，不能将很耗时的操作（如外部服务调用）与数据修改置于同一个事务中。此方案只是尽量减少两个事务中的写操作互相影响的可能，无法完全避免。
- 使用 ORM save 方法实现数据持久化的情况下，开启 Dynamic update，使得保存更改时影响的字段仅限于被改动了字段。此方案通过控制更新字段的范围，尽量减少脏操作可能，但也无法完全避免。

## 关于 Hibernate Dynamic update

主要缺陷

- 语义错位。本意是直接修改部分属性，现在变成取整个 Object，改部分属性，存整个 Object。中间不可控因素太多。
- 每次根据改动了的字段，动态生成 SQL 语句，性能上相比全更操作有所降低
- 需要从数据库拿到整个 Object 所有数据才能修改，大多数时候不必要，
- 当两个 session 同时对同一字段进行更新操作，极端情况下会因为 ORM 缓存出现莫名其妙的情况，示例见：[Stackexchange Q: What's the overhead of updating all columns, even the ones that haven't changed](https://dba.stackexchange.com/questions/176582/whats-the-overhead-of-updating-all-columns-even-the-ones-that-havent-changed)

## 如何更新数据库字段

- 拒绝使用 Spring Data JPA 的 save 方法
  - 默认配置且未使用锁的情况下，save 方法会更新实体类的所有字段，一方面增加了开销，另一方面歪曲了更新特定字段的语义，多线程并发访问更新下的情况下易出现问题。
  - 配置动态更新且未使用锁的情况下，save 方法会监测改动了的字段并进行更新，但是可能会出现 11 点中提到的古怪情形。
  - 总的来看，使用 ORM save 方法进行实体类更新陷入了 “You wanted a banana but you got a gorilla holding the banana” 的怪圈，导致做的事情不精确、或者有其它的风险。[参考文章](https://www.johndcook.com/blog/2011/07/19/you-wanted-banana/)
- 使用自定义 SQL 进行字段更新
  - 使用 JPA 提供的 @Query/@Modifying 书写 JPQL 进行精确控制的字段更新操作。

## 处理 Hibernate 懒加载

什么是懒加载

> An object that doesn't contain all of the data you need but knows how to get it.
> \- Martin Fowler defines in [Patterns of Enterprise Application Architecture](https://martinfowler.com/books/eaa.html)

懒加载在我们项目中带来的问题：

- 使用 Spring Data JPA 进行包含列表子对象的对象的列表查询时，若最后使用的结果集不仅限于该对象本身，而还包含其子对象中的内容，会出现 N + 1 问题
- 使用 Spring Data JPA 查询数据时，若是从非 Controller 环境（如消息队列消费者等异步线程环境），访问对象下面的列表子对象会出现 session closed 异常

对付 N + 1 问题：

- 列表查询改用 Spring Jdbc Template 直接书写原生 SQL 语句执行查询，最大程度上提高效率

对付非事务环境下访问懒加载数据 session closed 问题：

1. 设置 Hibernate 属性(v4.1.6 版本后可用)：hibernate.enable_lazy_load_no_trans=true
2. 使用 @Fetch(FetchMode.JOIN) 注解
3. 使用 @LazyCollection(LazyCollectionOption.FALSE) 注解
4. 其它请补充

## 使用 AspectJ

建议 AOP 用 aspectJ：

```xml
<tx:annotation-driven transaction-manager="transactionManager" mode="aspectj"/>
```

相较于 Java JDK 代理、Cglib 等，AspectJ 不但 runtime 性能提高一个数量级，而且支持 class，method（public or private) 和同一个类的方法调用。可以把@Transaction 写到最相关的地方。坏处是配置和 build 可能稍稍有些麻烦。

## 不建议用乐观锁

不建议用乐观锁。所有的事物都明明白白的写出事物处理控制语句。如果更新不需要检查条件（比如更改地址），则直接更新，后面的提交可能覆盖前面的版本。

如果更新有一定条件，比如取消订单需要订单的状态是可取消状态，则更新时需要先用 select for update 检查更新的条件符合再更新，不符合条件返回相应的业务错误代码。乐观锁适用于读的版本是最新的数据版本。

## 事务的使用

1. 所有查询放在事务之外，多条查询考虑用 readOnly 模式，建议用 READ COMMITTED 事物级别。但是外层事务 readOnly 事务会覆盖内层事务，使内层非只读事务表现出只读特性，我们的处理方式：(待补充)
2. 远程调用与事务，事物过程里面不许有远程调用。
3. 在处理中应该先完成一个表的所有操作再处理下一个表的操作。相关的表进行的操作相邻。先业务表再 history/audit 之类的辅助表操作。
4. 在事物里面处理多个表时，程序各处一定要按照同样的顺序。最好时按照聚合群的概念，从根部的表开始，广度优先，每层指定表的顺序。
5. 多个表的操作最好封装到一个函数/方法里面。
6. 序列号生成使用下面的事物模式：

```java
 @Transactional(propagation = Propagation.REQUIRES_NEW, isolation = Isolation.SERIALIZABLE)
```

## 减少外键使用

插入操作会需要 S lock 所有的外键。所以像 History 或审计之类的表不要和主要业务表建立外键，可以建个索引用于快速查询就是了，这样也实现了表之间的解耦。

## 锁的使用

尽可能避免表级别的锁。如果很多需要串行处理的操作，可以建立一个辅助的只有一行的 semaphore（信号）表，事物开始时先修改这个表，然后进行其他业务处理。

## 读现象

事务不隔离会带来的问题：

- 更新丢失(Lost updates): 针对并发写数据

  两事务同时更新，A 失败回滚覆盖 B 事务的更新，或事务 A 执行更新操作，在事务 A 结束前事务 B 也更新，则事务 A 的更新结果被事务 B 的覆盖。

- 脏读(Dirty reads): 针对未提交数据

  事务 A 对数据进行了更新，但还没有提交，事务 B 可以读取到事务 A 没有提交的更新结果，这样造成的问题就是，如果事务 A 回滚，那么，事务 B 在此之前所读取的数据就是一笔脏数据。

- 不可重复读(Non-repeatable reads): 针对其他提交前后，读取数据本身的对比

  不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务 A 在事务 B 的更新操作之前读取一次数据，在事务 B 的更新操作之后再读取同一笔数据一次，两次结果是不同的。

- 幻读(Phantom reads): 针对其他提交前后，读取数据条数的对比

  幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。

## 事务隔离级别

数据库事务有四种隔离级别，由低到高分别为：

- 读未提交（Read uncommitted，RU）

  最低的隔离级别，指的是一个事务可以读其他事务未提交的数据。

- 读提交（Read committed，RC）

  一个事务要等另一个事务提交后才能读取数据。

- 可重复读（Repeatable Read，RR）

  在开始读取数据（事务开启）时，不再允许修改操作。

- 串行化（Serializable，S）

  最高的事务隔离级别，事务串行化顺序执行。

### 不可重复读与幻读的区别

不可重复读的重点是修改，指的是同样条件读取过的数据，再次读取出来发现值不一样。
幻读的重点是数据条数的变化（新增或删除），指的是同样的条件，两次读出来的记录数不一样

### 隔离级别与读现象

|              | 更新丢失 | 脏读 | 不可重复读 | 幻读 |
| ------------ | -------- | ---- | ---------- | ---- |
| 读未提交(RU) | 避免     |      |            |      |
| 读提交(RC)   | 避免     | 避免 |            |      |
| 可重复读(RR) | 避免     | 避免 | 避免       |      |
| 串行化(S)    | 避免     | 避免 | 避免       | 避免 |

## 参考文档

- [Isolation (database systems)](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Read_phenomena)
