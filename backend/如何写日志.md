# 如何写日志(后台)

如同错误处理代码，日志也是程序的重要组成部分。尤其是分布式并行程序，很多时候日志是唯一有效的调试方法。传统的日志偏重运行时的错误调试，现在的日志增加了运维的功能。一个典型的程序包括三分之一正常业务处理逻辑，三分之一异常业务处理，还有三分之一是 log 代码，在不同层次记录系统的运行路径和关键运维/调试数据。

鉴于日志的重要性及不改变运行代码的要求，禁止用 AOP 这种简化工具来写日志信息。

## 日志的基本原则

- 日志的用户是系统运维人员和程序员，和业务人员无关。
- 日志有五个级别：Error， Warning， Info， Debug， Trace。
- 正常状态的日志级别是 Info，其用户是系统运维人员。用于发现错误和性能问题。
- 开发人员用 Debug 和 Trace 级别来定位错误。
- 日志是运维和查错的重要工具，要和业务代码一样认真对待。
- 记录完整的执行路径和相关业务信息。不要有重复信息。
- 通常一个函数只需要一个进入或退出时的信息。调用函数也不重复被调用函数的日志信息。
- 任何错误/异常发生的地方都要用日志记录。
- 仔细规划日志的级别，如果下面的通用指南不够清醒，请在业务模块给出清醒的日志级别指南。

## 日志级别的使用指南

Error 表示严重错误，应用程序无法执行。比如运行错误、不能连接到数据库、调用参数错误或严重业务数据错误。Error 级别的错误属于高优先级 bug，需要开发人员立即修复。

Warning 表示不影响程序继续运行的各种系统错误，比如网络超时。运维人员需要每天留意 Warning 信息，看看是否有异常情况。

Info 表示一个重要的系统事件。可以给系统运维人员提供重要的系统运行状态。Info 事件的频率应该在分钟级，即针对一个用户的操作，在一分钟内应该只有一条或几条记录。常见的 Info 事件有：

- 系统的生命周期：启动、初始化、停止等。
- 重要的业务事件：比如登录、登出、创建新用户、密码重置、登录错误。
- 重要的跨业务模块（跨进程）的请求的开始和结束：REST/RPC API 的调用。用于监控系统性能。

Debug 是调试的主要级别。这个级别的信息应该给出完整的执行路径和重要的执行结果。打印的信息不应该太详细（比如有十个以上的属性），也不应该用在重复十次以上的循环内部。

Trace 给出详细的程序运行状态。Trace 可以用在循环的内部或用于打印完整的详细信息。当输出详细信息是，通常也先有一个 Debug 级别的摘要信息。比如，Debug 信息给出数组的尺寸，而 Trace 级别给出具体的数组数据（所有元素或一部分元素）。

## 日志格式

日志是给系统运维和开发人员看的。所以给出的信息也是以程序调试为主。常见二种格式

```java
// 格式一
LOG.info('user 1234 clicked on the save button on the sign-up page')

// 格式二
LOG.info('userId:1234 clicked on buttonId:save on pageId:sign-up')
```

第二种格式给出了具体的变量名称和对应状态值，是推荐的日志格式。即参数名和参数值之间用':'分隔。

Info和Debug级别的日志应成对出现，通常在函数出入口进行记录, 推荐格式如下：

```java
// "Enter. "作为推荐的函数进入点的日志格式标准，后面可以加上关键参数的信息
LOG.debug("Enter. orderId:{}, employeeId:{}", order.getId(), employee.getId());

// "Exit"作为推荐的函数退出点的日志格式标准
LOG.debug("Exit");

// 有返回值时，也可以记录返回的参数描述
LOG.debug("Exit. return value:{}", returnValue);
```

## 日志效果

当系统运行时，用 Info 层级记录重要的业务和系统事件。比如，系统启动了，初始化完成，连接到数据库，用户登录了，用户改口令了，用户完成一个订单等频率在分钟级，而且重要的事件。系统的 Warning 日志需要每天分析，Error 则要立刻处理。

当运行到 Debug 状态，应该给出系统的主要运行路径。比如搜素文本，准备参赛，发起请求，后台请求结果个数。不同条件执行的不同功能及其概要信息一目了然。数据的频率应该在秒级，即一般一秒有不超过 10 条信息。

当运行到 Trace 状态，则需要给出详细数据，数组的元素列表或循环内的数据状态。数据量大而且频率会很高。

## 日志最佳实践

- 日志语句中不要调用耗时的方法（在关闭日志以后，日志对性能的影响应该可以忽略不记）

```java
1. LOG.trace("Enter. request:{}", JsonUtils.toJson(params));
2. LOG.trace("Enter. request:{}", params);
```

第一种方法在关闭日志以后以会有函数调用toJson，会对性能造成影响，避免使用；  
第二种方法在真正记录日志时才会调用params的toString()方法，推荐使用。

## Tmc后台日志示例

### Tmc后台日志级别确定：

- 顶层的重要业务（改变业务状态）都需Info级别的进出口日志。大订单和各产品订单的操作都属于顶层业务，产品订单的具体处理步骤都是Debug或Trace级别。
- 对于查询业务一般为Debug或Trace级别，对于特别关注的查询业务，比如机票查询请求，也可以记录为Info级别。
- 只有顶层才有Info, 其他子层级不应该有Info级别。
- 定时任务也视为顶层操作，需要Info级别.

### 后台订单取消操作分析：

后台取消确认操作，从用户角度看，这是一个比较大的业务操作，系统运维人员需要知道这个操作的起止时间和状态，所以在Applicaton顶层方法里需要一个Info级别的信息，记录操作的开始和结束状态。开始的状态只有一个任务id，所以开始的日志记录应该包括任务id，日志信息应为"Enter taskId=1234"。

取消操作顶层的所有出口（包括throw Exception）需要Info级别以上的Log。

出口有两种状态，成功和失败。

对于成功的状态，日志级别为Info, 信息为"Exit"，如果操作需要返回数据，这里应记录概要数据。比如"Exit. data:1234"。（对于登录接口的密码错误是正常业务状态，也应属于成功。）

对于失败的状态，在抛出异常的地方要记录日志，根据错误程度级别分别为Error或Warning。 其中Error表示严重系统或应用错误，需要运维或程序员尽快修复，Warning为不正常的系统状态（比如网络超时错误）或不应该发生的应用状态（比如订单状态为不可取消状态），需要运维或程序员关注。

对于取消订单而言，未找到对应的待取消订单或订单状态不能取消，属于不应该发生的事情，但不影响系统正常运行，应属于Warining级别，需要程序员关注，找出发生的原因。

取消订单包括很多子步骤，所有这些子步骤的日志信息应该为Debug级别，
